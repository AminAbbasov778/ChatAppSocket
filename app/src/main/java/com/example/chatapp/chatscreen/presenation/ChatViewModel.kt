package com.example.chatapp.chatscreen.presenationimport android.util.Logimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.example.chatapp.Constants.MY_USER_IDimport com.example.chatapp.core.presentation.mappers.toDomainimport com.example.chatapp.core.presentation.mappers.toUiimport com.example.chatapp.chatscreen.domain.EnterChatUseCaseimport com.example.chatapp.core.domain.usecases.GetMessagesUseCaseimport com.example.chatapp.core.domain.usecases.GetUsersUseCaseimport com.example.chatapp.chatscreen.domain.SendMessageUseCaseimport com.example.chatapp.core.presentation.models.MessageUiimport dagger.hilt.android.lifecycle.HiltViewModelimport kotlinx.coroutines.Jobimport kotlinx.coroutines.delayimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.flow.asStateFlowimport kotlinx.coroutines.flow.updateimport kotlinx.coroutines.launchimport javax.inject.Inject@HiltViewModelclass ChatViewModel @Inject constructor(    private val enterChatUseCase: EnterChatUseCase,    private val sendMessageUseCase: SendMessageUseCase,    private val getMessagesUseCase: GetMessagesUseCase,    private val getUsersUseCase: GetUsersUseCase,) : ViewModel() {    private val _state = MutableStateFlow(ChatState())    val state: StateFlow<ChatState> = _state.asStateFlow()    private var lastTimerJob: Job? = null    private fun observeIncomingMessages(recieverId: String) {        viewModelScope.launch {            getMessagesUseCase().collect { message ->                val uiMessage = message.toUi(MY_USER_ID)                val isRelevant = (uiMessage.senderId == recieverId || uiMessage.receiverId == recieverId)                if (!isRelevant) return@collect                if (!uiMessage.isMine) {                    _state.update { it.copy(messages = it.messages + uiMessage) }                }               delay(uiMessage)            }        }    }    fun clearState() {        _state.update { it.copy(messages = emptyList()) }    }    fun onEvent(event: ChatEvent) {        when (event) {            is ChatEvent.UpdateText -> _state.update { it.copy(messageText = event.text) }            is ChatEvent.SendMessage -> {                val msg = MessageUi(                    senderId = MY_USER_ID,                    message = event.message.trim(),                    timestamp = System.currentTimeMillis().toString(),                    isMine = true,                    receiverId = event.recieverId,                    isTimeVisible = false                )                if (msg.message.isEmpty()) return                sendMessageUseCase(msg.toDomain())                _state.update { it.copy(messages = it.messages + msg, messageText = "") }             delay(msg)            }            is ChatEvent.EnterChat -> {                getUsers(event.userId)                enterChatUseCase(event.userId)            }            is ChatEvent.MessageReceived -> {                _state.update { it.copy(messages = it.messages + event.message) }            }            is ChatEvent.ObserveIncomingMessages -> observeIncomingMessages(event.recieverId)            ChatEvent.ClearState -> clearState()        }    }    private fun delay(msg : MessageUi){        lastTimerJob?.cancel()        lastTimerJob = viewModelScope.launch {            delay(10000)            _state.update { currentState ->                val updatedMessages = currentState.messages.map {                    if (it.timestamp == msg.timestamp && it.message == msg.message)                        it.copy(isTimeVisible = true)                    else it                }                currentState.copy(messages = updatedMessages)            }        }    }    private fun getUsers(recieverId: String) {        viewModelScope.launch {            enterChatUseCase(MY_USER_ID)            getUsersUseCase(MY_USER_ID).collect { user ->                Log.d("user", user.toString())                if (user.id == recieverId) {                    _state.update { it.copy(sender = user.toUi()) }                }            }        }    }}